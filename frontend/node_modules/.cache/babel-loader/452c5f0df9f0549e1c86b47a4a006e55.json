{"ast":null,"code":"import _pick from \"lodash/pick\";\nimport _isFunction from \"lodash/isFunction\";\nimport _defaults from \"lodash/defaults\";\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport { VictoryTooltip } from \"victory-tooltip\";\nimport { VictoryContainer, Helpers, TextSize } from \"victory-core\";\nimport VoronoiHelpers from \"./voronoi-helpers\";\nexport var voronoiContainerMixin = function voronoiContainerMixin(base) {\n  var _class, _temp;\n\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_base) {\n    _inherits(VictoryVoronoiContainer, _base);\n\n    function VictoryVoronoiContainer() {\n      _classCallCheck(this, VictoryVoronoiContainer);\n\n      return _possibleConstructorReturn(this, (VictoryVoronoiContainer.__proto__ || Object.getPrototypeOf(VictoryVoronoiContainer)).apply(this, arguments));\n    }\n\n    _createClass(VictoryVoronoiContainer, [{\n      key: \"getLabelPadding\",\n      value: function getLabelPadding(style) {\n        if (!style) {\n          return 0;\n        }\n\n        var paddings = Array.isArray(style) ? style.map(function (s) {\n          return s.padding;\n        }) : [style.padding];\n        return Math.max.apply(Math, _toConsumableArray(paddings).concat([0]));\n      }\n    }, {\n      key: \"getFlyoutSize\",\n      value: function getFlyoutSize(labelComponent, text, style) {\n        var padding = this.getLabelPadding(style);\n        var textSize = TextSize.approximateTextSize(text, style);\n        return {\n          x: labelComponent.width || textSize.width + padding,\n          y: labelComponent.height || textSize.height + padding\n        };\n      }\n    }, {\n      key: \"getLabelCornerRadius\",\n      value: function getLabelCornerRadius(props, labelProps) {\n        if (labelProps.cornerRadius !== undefined) {\n          return labelProps.cornerRadius;\n        }\n\n        var theme = props.theme || labelProps.theme;\n        return theme.tooltip && theme.tooltip.cornerRadius || 0;\n      }\n    }, {\n      key: \"getFlyoutExtent\",\n      value: function getFlyoutExtent(position, props, labelProps) {\n        var text = labelProps.text,\n            style = labelProps.style;\n        var orientation = labelProps.orientation,\n            _labelProps$dx = labelProps.dx,\n            dx = _labelProps$dx === void 0 ? 0 : _labelProps$dx,\n            _labelProps$dy = labelProps.dy,\n            dy = _labelProps$dy === void 0 ? 0 : _labelProps$dy;\n        var flyoutSize = this.getFlyoutSize(props.labelComponent, text, style);\n        var cornerRadius = this.getLabelCornerRadius(props, labelProps);\n        var x = position.x + dx + 2 * cornerRadius;\n        var y = position.y + dy + 2 * cornerRadius;\n        var width = orientation === \"top\" || orientation === \"bottom\" ? flyoutSize.x / 2 : flyoutSize.x;\n        var horizontalSign = orientation === \"left\" ? -1 : 1;\n        var verticalSign = orientation === \"bottom\" ? 1 : -1;\n        var extent = {};\n\n        if (orientation === \"top\" || orientation === \"bottom\") {\n          extent.x = [x - width, x + width];\n        } else {\n          extent.x = [x, x + horizontalSign * width];\n        }\n\n        extent.y = [y, y + verticalSign * flyoutSize.y];\n        return {\n          x: [Math.min.apply(Math, _toConsumableArray(extent.x)), Math.max.apply(Math, _toConsumableArray(extent.x))],\n          y: [Math.min.apply(Math, _toConsumableArray(extent.y)), Math.max.apply(Math, _toConsumableArray(extent.y))]\n        };\n      }\n    }, {\n      key: \"getPoint\",\n      value: function getPoint(props, point) {\n        var whitelist = [\"_x\", \"_x1\", \"_x0\", \"_y\", \"_y1\", \"_y0\"];\n\n        if (!props.horizontal) {\n          return _pick(point, whitelist);\n        }\n\n        return {\n          _x: point._y,\n          _y: point._x,\n          _x1: point._y1,\n          _y1: point._x1,\n          _x0: point._y0,\n          _y0: point._x0\n        };\n      }\n    }, {\n      key: \"getLabelPosition\",\n      value: function getLabelPosition(props, points, labelProps) {\n        var mousePosition = props.mousePosition,\n            voronoiDimension = props.voronoiDimension,\n            scale = props.scale,\n            voronoiPadding = props.voronoiPadding;\n        var point = this.getPoint(props, points[0]);\n        var basePosition = Helpers.scalePoint(props, point);\n\n        if (!voronoiDimension || points.length < 2) {\n          return basePosition;\n        }\n\n        var x = voronoiDimension === \"y\" ? mousePosition.x : basePosition.x;\n        var y = voronoiDimension === \"x\" ? mousePosition.y : basePosition.y;\n\n        if (props.polar) {\n          // TODO: Should multi-point tooltips be constrained within a circular chart?\n          return {\n            x: x,\n            y: y\n          };\n        }\n\n        var range = {\n          x: scale.x.range(),\n          y: scale.y.range()\n        };\n        var extent = {\n          x: [Math.min.apply(Math, _toConsumableArray(range.x)) + voronoiPadding, Math.max.apply(Math, _toConsumableArray(range.x)) - voronoiPadding],\n          y: [Math.min.apply(Math, _toConsumableArray(range.y)) + voronoiPadding, Math.max.apply(Math, _toConsumableArray(range.y)) - voronoiPadding]\n        };\n        var flyoutExtent = this.getFlyoutExtent({\n          x: x,\n          y: y\n        }, props, labelProps);\n        var adjustments = {\n          x: [flyoutExtent.x[0] < extent.x[0] ? extent.x[0] - flyoutExtent.x[0] : 0, flyoutExtent.x[1] > extent.x[1] ? flyoutExtent.x[1] - extent.x[1] : 0],\n          y: [flyoutExtent.y[0] < extent.y[0] ? extent.y[0] - flyoutExtent.y[0] : 0, flyoutExtent.y[1] > extent.y[1] ? flyoutExtent.y[1] - extent.y[1] : 0]\n        };\n        return {\n          x: Math.round(x + adjustments.x[0] - adjustments.x[1]),\n          y: Math.round(y + adjustments.y[0] - adjustments.y[1])\n        };\n      }\n    }, {\n      key: \"getStyle\",\n      value: function getStyle(props, points, type) {\n        var labels = props.labels,\n            labelComponent = props.labelComponent,\n            theme = props.theme;\n        var componentProps = labelComponent.props || {};\n        var themeStyles = theme && theme.voronoi && theme.voronoi.style ? theme.voronoi.style : {};\n        var componentStyleArray = type === \"flyout\" ? componentProps.flyoutStyle : componentProps.style;\n        return points.reduce(function (memo, point, index) {\n          var text = _isFunction(labels) ? labels(point, index, points) : undefined;\n          var textArray = text !== undefined ? \"\".concat(text).split(\"\\n\") : [];\n          var baseStyle = point.style && point.style[type] || {};\n          var componentStyle = Array.isArray(componentStyleArray) ? componentStyleArray[index] : componentStyleArray;\n          var style = Helpers.evaluateStyle(_defaults({}, componentStyle, baseStyle, themeStyles[type]), point, true);\n          var styleArray = textArray.length ? textArray.map(function () {\n            return style;\n          }) : [style];\n          memo = memo.concat(styleArray);\n          return memo;\n        }, []);\n      }\n    }, {\n      key: \"getDefaultLabelProps\",\n      value: function getDefaultLabelProps(props, points) {\n        var voronoiDimension = props.voronoiDimension,\n            horizontal = props.horizontal;\n        var point = this.getPoint(props, points[0]);\n        var multiPoint = voronoiDimension && points.length > 1;\n        var y = point._y1 !== undefined ? point._y1 : point._y;\n        var defaultHorizontalOrientation = y < 0 ? \"left\" : \"right\";\n        var defaultOrientation = y < 0 ? \"bottom\" : \"top\";\n        var orientation = horizontal ? defaultHorizontalOrientation : defaultOrientation;\n        return {\n          orientation: multiPoint ? \"top\" : orientation,\n          pointerLength: multiPoint ? 0 : undefined\n        };\n      }\n    }, {\n      key: \"getLabelProps\",\n      value: function getLabelProps(props, points) {\n        var labels = props.labels,\n            scale = props.scale,\n            labelComponent = props.labelComponent,\n            theme = props.theme;\n        var text = points.reduce(function (memo, point, index) {\n          var t = _isFunction(labels) ? labels(point, index, points) : null;\n\n          if (t === null || t === undefined) {\n            return memo;\n          }\n\n          memo = memo.concat(\"\".concat(t).split(\"\\n\"));\n          return memo;\n        }, []);\n        var componentProps = labelComponent.props || {}; // remove properties from first point to make datum\n        // eslint-disable-next-line no-unused-vars\n\n        var _points$ = points[0],\n            childName = _points$.childName,\n            eventKey = _points$.eventKey,\n            style = _points$.style,\n            continuous = _points$.continuous,\n            datum = _objectWithoutProperties(_points$, [\"childName\", \"eventKey\", \"style\", \"continuous\"]);\n\n        var name = props.name === childName ? childName : \"\".concat(props.name, \"-\").concat(childName);\n\n        var labelProps = _defaults({\n          key: \"\".concat(name, \"-\").concat(eventKey, \"-voronoi-tooltip\"),\n          id: \"\".concat(name, \"-\").concat(eventKey, \"-voronoi-tooltip\"),\n          active: true,\n          flyoutStyle: this.getStyle(props, points, \"flyout\")[0],\n          renderInPortal: false,\n          style: this.getStyle(props, points, \"labels\"),\n          datum: datum,\n          scale: scale,\n          theme: theme,\n          text: text\n        }, componentProps, this.getDefaultLabelProps(props, points));\n\n        var labelPosition = this.getLabelPosition(props, points, labelProps);\n        return _defaults({}, labelPosition, labelProps);\n      }\n    }, {\n      key: \"getTooltip\",\n      value: function getTooltip(props) {\n        var labels = props.labels,\n            activePoints = props.activePoints,\n            labelComponent = props.labelComponent;\n\n        if (!labels) {\n          return null;\n        }\n\n        if (Array.isArray(activePoints) && activePoints.length) {\n          return React.cloneElement(labelComponent, this.getLabelProps(props, activePoints));\n        } else {\n          return null;\n        }\n      } // Overrides method in VictoryContainer\n\n    }, {\n      key: \"getChildren\",\n      value: function getChildren(props) {\n        return _toConsumableArray(React.Children.toArray(props.children)).concat([this.getTooltip(props)]);\n      }\n    }]);\n\n    return VictoryVoronoiContainer;\n  }(base), Object.defineProperty(_class, \"displayName\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: \"VictoryVoronoiContainer\"\n  }), Object.defineProperty(_class, \"propTypes\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: _objectSpread({}, VictoryContainer.propTypes, {\n      activateData: PropTypes.bool,\n      activateLabels: PropTypes.bool,\n      disable: PropTypes.bool,\n      labelComponent: PropTypes.element,\n      labels: PropTypes.func,\n      onActivated: PropTypes.func,\n      onDeactivated: PropTypes.func,\n      radius: PropTypes.number,\n      voronoiBlacklist: PropTypes.arrayOf(PropTypes.string),\n      voronoiDimension: PropTypes.oneOf([\"x\", \"y\"]),\n      voronoiPadding: PropTypes.number\n    })\n  }), Object.defineProperty(_class, \"defaultProps\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: _objectSpread({}, VictoryContainer.defaultProps, {\n      activateData: true,\n      activateLabels: true,\n      labelComponent: React.createElement(VictoryTooltip, null),\n      voronoiPadding: 5\n    })\n  }), Object.defineProperty(_class, \"defaultEvents\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: function value(props) {\n      return [{\n        target: \"parent\",\n        eventHandlers: {\n          onMouseLeave: function onMouseLeave(evt, targetProps) {\n            return props.disable ? {} : VoronoiHelpers.onMouseLeave(evt, targetProps);\n          },\n          onTouchCancel: function onTouchCancel(evt, targetProps) {\n            return props.disable ? {} : VoronoiHelpers.onMouseLeave(evt, targetProps);\n          },\n          onMouseMove: function onMouseMove(evt, targetProps) {\n            return props.disable ? {} : VoronoiHelpers.onMouseMove(evt, targetProps);\n          },\n          onTouchMove: function onTouchMove(evt, targetProps) {\n            return props.disable ? {} : VoronoiHelpers.onMouseMove(evt, targetProps);\n          }\n        }\n      }, {\n        target: \"data\",\n        eventHandlers: props.disable ? {} : {\n          onMouseOver: function onMouseOver() {\n            return null;\n          },\n          onMouseOut: function onMouseOut() {\n            return null;\n          },\n          onMouseMove: function onMouseMove() {\n            return null;\n          }\n        }\n      }];\n    }\n  }), _temp;\n};\nexport default voronoiContainerMixin(VictoryContainer);","map":null,"metadata":{},"sourceType":"module"}